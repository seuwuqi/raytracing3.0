<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="UTF-8">

    <title>threejs-basic-geometry</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
    <title>Bootstrap 101 Template</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <style type="text/css">
        .my_output_bottom_left {
            background-color: #c3c3c3;
            bottom: 0px;
        }
    </style>
</head>



<body>

    <!--导航-->
    <header class="navbar fixed-top navbar-expand-sm bg-dark navbar-dark">
        <ul class="nav nav-pills">
            <li class="nav-item">
                <a class="nav-link active" href="javascript:;" onclick="sendMessage('2')">开始程序</a>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true"
                    aria-expanded="false">设置</a>
                <div class="dropdown-menu">
                    <button class="dropdown-item" data-toggle="modal" data-target="#exampleModalCenter">选择区域地图</button>
                    <a class="dropdown-item" href="#">建筑设置</a>
                    <a class="dropdown-item"  href="javascript:;" onclick="sendMessage('3')">显示道路</a>
                    <div class="dropdown-divider"></div>
                    <a class="dropdown-item" href="#">亮度设置</a>
                    <a class="dropdown-item" href="#">鼠标灵敏度设置</a>
                    <a class="dropdown-item" href="#">锁定地图显示</a>
                </div>
            </li>
            <li class="nav-item">
                <button type="button" class="btn btn-success" onclick="setTx()">set tx</button>

                <button type="button" class="btn btn-secondary" onclick="setRx()">set rx</button>

                <button type="button" class="btn btn-danger" onclick="reset()">reset</button>
                <a class="btn btn-primary" data-toggle="collapse" href="#collapseExample" role="button" aria-expanded="false"
                    aria-controls="collapseExample">
                    Link with href
                </a>
                <a class="btn btn-primary" data-toggle="collapse" href="#collapseExample01" role="button" aria-expanded="false"
                    aria-controls="collapseExample01">
                    Link with href
                </a>

            </li>


            <li class="nav-item">
                <a class="nav-link disabled" href="#">离开</a>
            </li>
        </ul>
        <canvas id="locationCanvas" width="200" height="40" style="border:1px solid #c3c3c3;">
            Your browser does not support the canvas element.
        </canvas>


    </header>


    <!--显示界面-->
    <div class="row">
        <div class="col-md-12">

            <div id="webgl" class="card card-success w-100 h-100" style="height:800px"></div>
            <div class="collapse position-absolute" id="collapseExample" style="bottom:0px">
                <div class="card card-body">
                    <div style="height: 400px" class="card card-success">
                        <table class="table table-hover">
                            <thead>
                                <tr class="active">
                                    <th>Car ID</th>
                                    <th>RX</th>
                                    <th>Coordinate</th>
                                    <th>Type</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="table-success">
                                    <td><button type="button" class="btn btn-success btn-sm" data-toggle="tooltip"
                                            data-placement="bottom" title="点击可以更新车辆状态">
                                            001
                                        </button></td>
                                    <td>True</td>
                                    <td>(13.5,6.2)</td>
                                    <td>A</td>
                                </tr>
                                <tr class="table-danger">
                                    <td><button type="button" class="btn btn-danger btn-sm" data-toggle="tooltip"
                                            data-placement="bottom" title="点击可以更新车辆状态">
                                            002
                                        </button></td>
                                    <td>False</td>
                                    <td>(14.5,7.5)</td>
                                    <td>A</td>
                                </tr>
                                <tr class="table-danger">
                                    <td><button type="button" class="btn btn-danger btn-sm" data-toggle="tooltip"
                                            data-placement="bottom" title="点击可以更新车辆状态">
                                            003
                                        </button></td>
                                    <td>False</td>
                                    <td>(17.7,5.2)</td>
                                    <td>A</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="collapse position-absolute" id="collapseExample01" style="bottom:0px;right: 0px;" >
                <div class="card card-body">
                    <!--数据展示部分 container-->
                    <div class="container">
                        <div class="card card-success">
                            <div class="btn-group btn-group-sm">
                                <button id="pathloss" type="button" class="btn btn-primary">路径损耗</button>
                                <button id="powerdelay" type="button" class="btn btn-secondary">功率时延分布</button>
                                <button id="meandelay" type="button" class="btn btn-success">平均附加时延</button>
                                <button id="dimpowerdelay" type="button" class="btn btn-danger">功率时延空间分布</button>
                            </div>
                            <div id="main" style="width:600px;height:400px"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>








    <!-- Modal 模态框-->
    <div class="modal fade" id="exampleModalCenter" tabindex="-1" role="dialog" aria-labelledby="exampleModalCenterTitle"
        aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Open File</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <form>
                        <div class="form-group">
                            <div class="custom-file">
                                <h5><span class="badge badge-secondary">shp文件:</span></h5>
                                <input type="file" class="form-control-file" id="exampleFormControlFile1">
                                <hr>
                                <h5><span class="badge badge-secondary">dbf文件:</span></h5>
                                <input type="file" class="form-control-file" id="exampleFormControlFile2">
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary">Open</button>
                </div>
            </div>
        </div>
    </div>



    <!--导入js-->
    <script type="text/javascript" src="js/three.js"></script>
    <script type="text/javascript" src="js/echarts.min.js"></script>
    <script type="text/javascript" src="js/echarts-gl.min.js"></script>
    <script type="text/javascript" src="js/Detector.js"></script>
    <script type="text/javascript" src="js/OrbitControls.js"></script>
    <script type="text/javascript" src="js/TDSLoader.js"></script>
    <script type="text/javascript" src="js/tether.min.js"></script>
    <script src="js/controls/DragControls.js"></script>
    <script src="js/controls/TrackballControls.js"></script>




    <script src="js/jquery.min.js"></script>
    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->
    <script src="js/bootstrap.min.js"></script>
    <!--websocket-->
    <script type="text/javascript">
        var sendCode;
        function debug(message) {
            console.log(message);
        }

        function sendMessage(msg) {
            if (websocket != null) {
                websocket.send(msg);
                console.log("string sent :", '"' + msg + '"');
            } else {
                //initWebSocket();
                websocket.send(msg);
                console.log("string sent :", '"' + msg + '"');
            }
            sendCode = msg;
            // stopWebSocket();
        }

        var wsUri = "ws://localhost:1234";
        var websocket = null;
        initWebSocket();

        function initWebSocket() {
            try {
                if (typeof MozWebSocket == 'function')
                    WebSocket = MozWebSocket;
                if (websocket && websocket.readyState == 1)
                    websocket.close();
                websocket = new WebSocket(wsUri);
                websocket.onopen = function (evt) {
                    sendMessage("1");
                    debug("CONNECTED");
                };
                websocket.onclose = function (evt) {
                    debug("DISCONNECTED");
                };
                websocket.onmessage = function (evt) {
                    console.log("Message received :", evt.data);
                    if (sendCode == "1") {
                        readFromDataToArray(evt.data);
                        sendMessage("cordinate");
                    } else if (sendCode == "2") {
                        drawPath(evt.data);
                    }else if(sendCode == "3"){
                        drawRoad(evt.data);
                    }else if (sendCode == "cordinate"){
                        processCordinate(evt.data);
                    }
                    //debug(evt.data);
                };
                websocket.onerror = function (evt) {
                    debug('ERROR: ' + evt.data);
                };
            } catch (exception) {
                debug('ERROR: ' + exception);
            }
        }

        function stopWebSocket() {
            if (websocket)
                websocket.close();
        }

        function checkSocket() {
            if (websocket != null) {
                var stateStr;
                switch (websocket.readyState) {
                    case 0: {
                        stateStr = "CONNECTING";
                        break;
                    }
                    case 1: {
                        stateStr = "OPEN";
                        break;
                    }
                    case 2: {
                        stateStr = "CLOSING";
                        break;
                    }
                    case 3: {
                        stateStr = "CLOSED";
                        break;
                    }
                    default: {
                        stateStr = "UNKNOW";
                        break;
                    }
                }
                debug("WebSocket state = " + websocket.readyState + " ( " + stateStr + " )");
            } else {
                debug("WebSocket is null");
            }
        }
    </script>

    <!--echart-->
    <script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var button1 = document.getElementById("pathloss");
        var button2 = document.getElementById("powerdelay");
        var button3 = document.getElementById("meandelay");
        var button4 = document.getElementById("dimpowerdelay");

        var myChart = echarts.init(document.getElementById("main"));
        button4.onclick = function (ev) {
            loadDimenPowerDelay();
        };
        button3.onclick = function (ev) {
            console.log("b3");
            loadbutton2();
        };



        function loadbutton2() {
            option = {
                title: {
                    text: '平均附加时延',
                    subtext: '附加时延'
                },
                tooltip: {},
                backgroundColor: '#fff',
                visualMap: {
                    show: false,
                    dimension: 2,
                    min: -1,
                    max: 1,
                    inRange: {
                        color: ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8', '#ffffbf', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026']
                    }
                },
                xAxis3D: {
                    type: 'value'
                },
                yAxis3D: {
                    type: 'value'
                },
                zAxis3D: {
                    type: 'value'
                },
                grid3D: {
                    viewControl: {
                        // projection: 'orthographic'
                    }
                },
                series: [{
                    type: 'surface',
                    wireframe: {
                        // show: false
                    },
                    equation: {
                        x: {
                            step: 0.05
                        },
                        y: {
                            step: 0.05
                        },
                        z: function (x, y) {
                            if (Math.abs(x) < 0.1 && Math.abs(y) < 0.1) {
                                return '-';
                            }
                            return Math.sin(x * Math.PI) * Math.sin(y * Math.PI);
                        }
                    }
                }]
            };
            myChart.setOption(option);
        }


        function loadDimenPowerDelay() {
            myChart.setOption({
                title: {
                    text: '功率时延空间分布',
                    subtext: '功率时延空间分布'
                },
                grid3D: {},
                xAxis3D: {},
                yAxis3D: {},
                zAxis3D: {},
                series: [{
                    type: 'scatter3D',
                    symbolSize: 1,
                    data: [
                        [-1, -1, -1],
                        [0, 0, 0],
                        [1, 1, 1]
                    ],
                    itemStyle: {
                        opacity: 1
                    }
                }]
            });
        }

        function loadPathLoss(pathLossOrder, pathLoss) {
            // 指定图表的配置项和数据
            option = {
                title: {
                    text: 'Ray-Tracing 路径损耗',
                    subtext: '路径损耗分布'
                },
                tooltip: {
                    trigger: 'axis'
                },
                legend: {
                    data: ['路径损耗']
                },
                toolbox: {
                    show: true,
                    feature: {
                        mark: {
                            show: true
                        },
                        dataView: {
                            show: true,
                            readOnly: false
                        },
                        magicType: {
                            show: true,
                            type: ['line', 'bar']
                        },
                        restore: {
                            show: true
                        },
                        saveAsImage: {
                            show: true
                        }
                    }
                },
                calculable: true,
                xAxis: [{
                    type: 'category',
                    data: pathLossOrder
                }],
                yAxis: [{
                    type: 'value'
                }],
                series: [{
                    name: '路径损耗/dB',
                    type: 'bar',
                    data: pathLoss,
                    markPoint: {
                        data: [{
                            type: 'max',
                            name: '最大值'
                        }, {
                            type: 'min',
                            name: '最小值'
                        }]
                    },
                    markLine: {
                        data: [{
                            type: 'average',
                            name: '平均值'
                        }]
                    }
                }]
            };
            // 使用刚指定的配置项和数据显示图表。
            myChart.setOption(option);
        }
    </script>

    <!--webgl-->
    <script type="text/javascript">
        //检测webgl的支持情况
        if (!Detector.webgl) {
            Detector.addGetWebGLMessage();
        }

        var container;
        var camera, scene, renderer;
        //用于轨道控制器
        var orbitControls, clock, delta;
        //loadXMLDoc();

        var mouse, raycaster, isShiftDown = false;
        var rollOverMesh, rollOverMaterial, rollOverGeo;
        var cubeMesh;
        var objects = [];

        var tx = [], rx = [];
        var xmax, xmin, ymax,ymin;

        var TxDTO;
        var RxDTO;
        main();
        render();
        loadPathLoss([1, 2, 3, 4, 5, 6], [-100, -101, -102, -103, -99, -98]);


        function setTx() {


            orbitControls.enabled = false;
            // roll-over helpers
            rollOverGeo = new THREE.BoxBufferGeometry(1, 0.5, 0.7);
            rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
            rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
            scene.add(rollOverMesh);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener('keydown', onDocumentKeyDown, false);
            document.addEventListener('keyup', onDocumentKeyUp, false);


        }


        function reset() {
            for (let i = 0; i < tx.length; i++) {
                scene.remove(tx[i]);
            }
            for (let i = 0; i < rx.length; i++) {
                scene.remove(rx[i]);
            }
        }

        function setRx() {

            orbitControls.enabled = false;
            // roll-over helpers
            rollOverGeo = new THREE.BoxBufferGeometry(1, 0.5, 0.7);
            rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
            rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
            scene.add(rollOverMesh);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mousedown', onDocumentMouseDown2, false);

        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function processCordinate(result) {
            var obj = JSON.parse(result);
            xmax = obj.xmax;
            xmin = obj.xmin;
            ymax = obj.ymax;
            ymin = obj.ymin;
        }
        function drawRoad(result){
            var obj = JSON.parse(result);
            console.log(obj[0][0].x);
            console.log(obj[0][0].y);

            for(var p in obj){
                var list = obj[p];
                var geometry = new THREE.Geometry();
                var material = new THREE.LineBasicMaterial( { vertexColors: true } );
                var color1 = new THREE.Color( 0x444444 ), color2 = new THREE.Color( 0xFF0000 );
                for (var i = 0; i < list.length - 1; i++) {
                    var p1 = new THREE.Vector3(list[i].y, 0, list[i].x);
                    var p2 = new THREE.Vector3(list[i + 1].y, 0, list[i + 1].x);
                    geometry.vertices.push(p1);
                    geometry.vertices.push(p2);
                    geometry.colors.push( color1, color2 );
                    var line = new THREE.Line( geometry, material, THREE.LineSegments );
                    scene.add(line);
                }


            }


        }
        function drawPath(result) {
            var obj = JSON.parse(result);
            console.log(obj[0][0].x);
            console.log(obj[0][0].y);

            for (var p in obj) {
                var list = obj[p];
                var geometry = new THREE.Geometry();
                var material = new THREE.LineBasicMaterial({ vertexColors: true });
                var color1 = new THREE.Color(0x444444), color2 = new THREE.Color(0xFF0000);
                for (var i = 0; i < list.length - 1; i++) {
                    var p1 = new THREE.Vector3(list[i].y, 0.5, list[i].x);
                    var p2 = new THREE.Vector3(list[i + 1].y, 0.5, list[i + 1].x);
                    geometry.vertices.push(p1);
                    geometry.vertices.push(p2);
                    geometry.colors.push(color1, color2);
                    var line = new THREE.Line(geometry, material, THREE.LineSegments);
                    scene.add(line);
                }


            }


        }
        function readFromDataToArray(result) {

            var obj = JSON.parse(result);
            console.log(obj[0][0].x)
            console.log(obj[0][0].y)
            //console.log(obj.length)
            var pointX = [];
            var pointY = [];
            var pointZ = [];

            for (var p in obj) {
                var data = obj[p];
                var pointXX = [];
                var pointYY = [];
                for (var i = 0; i < data.length; i++) {
                    pointXX.push(data[i].x);
                    pointYY.push(data[i].y);
                }

                pointX.push(pointXX);
                pointY.push(pointYY);
                pointZ.push(data[0].z);
            }
            // for (var i = 0; i < 261; i++) {
            //     var pointXX = [];
            //     var pointYY = [];
            //     for (var j = obj[i].length - 1; j >= 0; j--) {
            //         pointXX.push(obj[i][j].x);
            //         pointYY.push(obj[i][j].y);
            //     }
            //
            //     pointX.push(pointXX);
            //     pointY.push(pointYY);
            //     pointZ.push(obj[i][0].z);
            // }
            for (var i = 0; i < pointX.length; i++) {
                addMulGeometry(pointX[i], pointY[i], pointZ[i]);
            }
        }

        function loadPathLossGet() {
            var xmlhttp;
            if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
                xmlhttp = new XMLHttpRequest();
            } else { // code for IE6, IE5
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
            }
            xmlhttp.onreadystatechange = function () {
                if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                    var result = xmlhttp.responseText;
                    console.log(result);
                    //document.getElementById("myDiv").innerHTML=result;
                    var obj = JSON.parse(result);
                    console.log(obj.length);
                    var pathLossT = [];
                    var pathLossOrder = [];
                    for (var i = 0; i < obj.length; i++) {
                        pathLossT.push(obj[i]);
                        pathLossOrder.push(i);
                    }
                    //loadDimenPowerDelay();
                    loadPathLoss(pathLossOrder, pathLossT);
                }
            }
            xmlhttp.open("GET", "http://localhost:8080/user/getPathLoss.html", true);
            xmlhttp.send();
        }

        //主函数
        function loadXMLDoc() {
            var xmlhttp;
            if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
                xmlhttp = new XMLHttpRequest();
            } else { // code for IE6, IE5
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
            }
            xmlhttp.onreadystatechange = function () {
                if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                    var result = xmlhttp.responseText;
                    //document.getElementById("myDiv").innerHTML=result;
                    var obj = JSON.parse(result);
                    console.log(obj[0][0].x)
                    console.log(obj[0][0].y)
                    //console.log(obj.length)
                    var pointX = [];
                    var pointY = [];
                    var pointZ = [];
                    for (var i = 0; i < 261; i++) {
                        var pointXX = [];
                        var pointYY = [];
                        for (var j = obj[i].length - 1; j >= 0; j--) {
                            pointXX.push(obj[i][j].x);
                            pointYY.push(obj[i][j].y);
                        }
                        pointX.push(pointXX);
                        pointY.push(pointYY);
                        pointZ.push(obj[i][0].z);
                    }
                    main(pointX, pointY, pointZ);
                    render();
                    loadPathLossGet();

                    //alert(obj[0].length);
                }
            }
            xmlhttp.open("GET", "http://localhost:8080/user/hello.html", true);
            xmlhttp.send();
        }

        function load3DS(intersect, type) {
            var loader = new THREE.TDSLoader();

            loader.load("./Evo.3ds", function (object) {
                object.traverse(function (child) {
                    if (child instanceof THREE.Mesh) {
                        child.material.side = THREE.DoubleSide;
                        //child.material.normalMap = normal;
                    }
                });
                object.scale.set(0.002, 0.002, 0.002);
                object.position.copy(intersect.point);
                object.rotateX(Math.PI * 6 / 4);
                object.rotateZ(Math.PI * 6 / 4);
                scene.add(object);
                if (type == "tx") {
                    tx.push(object);
                } else if (type == "rx") {
                    rx.push(object);
                }

            });
        }


        function main() {
            //添加一个div元素
            container = document.getElementById('webgl')
            //document.body.appendChild(container);

            var width = window.innerWidth;
            var height = window.innerHeight;
            scene = new THREE.Scene(); //创建一个新场景
            //添加一个透视相机
            camera = new THREE.PerspectiveCamera(30,
                width / height, 1, 1000);
            camera.position.set(-100, 300, -100); //设置相机位置
            camera.lookAt(new THREE.Vector3(0, 0, 0)); //让相机指向原点
            //渲染
            //antialias:true增加抗锯齿效果
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setClearColor(new THREE.Color(0x000000)); //设置窗口背景颜色为黑
            renderer.setSize(width, height); //设置窗口尺寸
            //将renderer关联到container，这个过程类似于获取canvas元素
            container.appendChild(renderer.domElement);



            //添加轨道控制器
            // 新建一个轨道控制器
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.target = new THREE.Vector3(0, 0, 0); //控制焦点
            orbitControls.autoRotate = false; //将自动旋转关闭
            clock = new THREE.Clock(); //用于更新轨道控制器
            //给场景添加光源
            //自然光
            var ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            //平行光源
            var directionalLight = new THREE.DirectionalLight(0xffffff);
            directionalLight.position.set(1, 0.75, 0.5).normalize();
            scene.add(directionalLight);
            plane();


            var gridHelper = new THREE.GridHelper( 80, 30 );
            scene.add( gridHelper );
            window.addEventListener('resize', onWindowResize, false);
            // dragControlInit();
            //  var gridHelper = new THREE.GridHelper( 50, 100 );
            //  scene.add( gridHelper );
        }


        function plane() {
            var geometry = new THREE.PlaneBufferGeometry(100, 100);
            geometry.rotateX(- Math.PI/2 );
            plane = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: "#696969", visible: true }));
            scene.add(plane);
            objects.push(plane);
        }
        //创建一个立方体
        function cube() {
            //THREE.CubeGeometry(width,height,depth,widthSegments,heightSegments, depthSegments)
            var cubeGeo = new THREE.CubeGeometry(20, 20, 10, 15, 5, 5); //创建立方体
            var cubeMat = new THREE.MeshLambertMaterial({ //创建材料
                color: 0x003300,
                wireframe: false
            });
            cubeMesh = new THREE.Mesh(cubeGeo, cubeMat); //创建立方体网格模型
            cubeMesh.position.set(20, 10, 0); //设置立方体的坐标 几何中心
            scene.add(cubeMesh); //将立方体添加到场景中
        }

        //创建一个球
        function sphere() {
            var sphereGeo = new THREE.SphereGeometry(16, 40, 40); //创建球体
            var sphereMat = new THREE.MeshLambertMaterial({ //创建材料
                color: 0x0000FF,
                wireframe: false
            });
            var sphereMesh = new THREE.Mesh(sphereGeo, sphereMat); //创建球体网格模型
            sphereMesh.position.set(-25, 16, 0); //设置球的坐标
            scene.add(sphereMesh); //将球体添加到场景
        }

        //创建圆柱体
        function cylinder() {
            //创建圆柱体
            var cylinderGeo = new THREE.CylinderGeometry(15, 15, 40, 40, 40);
            var cylinderMat = new THREE.MeshLambertMaterial({ //创建材料
                color: 0xFF6600,
                wireframe: false
            });
            //创建圆柱体网格模型
            var cylinderMesh = new THREE.Mesh(cylinderGeo, cylinderMat);
            cylinderMesh.position.set(0, 20, -40); //设置圆柱坐标
            scene.add(cylinderMesh); //向场景添加圆柱体
        }

        function path() {
            var path = new THREE.Path();

            path.lineTo(0, 0.8);
            path.quadraticCurveTo(0, 1, 0.2, 1);
            path.lineTo(1, 1);

            var points = path.getPoints();

            var geometry = new THREE.BufferGeometry().setFromPoints(points);
            var material = new THREE.LineBasicMaterial({ color: 0xffffff });

            var line = new THREE.Line(geometry, material);
            scene.add(line);
        }



        //画线段
        function line() {
            var geometry = new THREE.Geometry();
            var material = new THREE.LineBasicMaterial({ vertexColors: true });
            var color1 = new THREE.Color(0x444444), color2 = new THREE.Color(0xFF0000);

            // 线的材质可以由2点的颜色决定
            var p1 = new THREE.Vector3(-25, 2, -25);
            var p2 = new THREE.Vector3(25, 2, -25);
            geometry.vertices.push(p1);
            geometry.vertices.push(p2);
            geometry.colors.push(color1, color2);
            var line1 = new THREE.Line(geometry, material, THREE.LineSegments);
            scene.add(line1);

            p1 = new THREE.Vector3(-25, 2, -25);
            p2 = new THREE.Vector3(-25, 2, 25);
            geometry.vertices.push(p1);
            geometry.vertices.push(p2);
            geometry.colors.push(color1, color2);
            var line2 = new THREE.Line(geometry, material, THREE.LineSegments);
            scene.add(line2);


            p1 = new THREE.Vector3(25, 2, 25);
            p2 = new THREE.Vector3(-25, 2, 25);
            geometry.vertices.push(p1);
            geometry.vertices.push(p2);
            geometry.colors.push(color1, color2);
            line3 = new THREE.Line(geometry, material, THREE.LineSegments);
            scene.add(line3);

            p1 = new THREE.Vector3(25, 2, 25);
            p2 = new THREE.Vector3(25, 2, -25);
            geometry.vertices.push(p1);
            geometry.vertices.push(p2);
            geometry.colors.push(color1, color2);
            var line4 = new THREE.Line(geometry, material, THREE.LineSegments);
            scene.add(line4);


            scene.add(line);
        }
        // 创建建筑
        function addMulGeometry(arrZ, arrX, height) {
            // var arrX=[4,0,0,2.5,4];
            // var arrZ=[4,4,0,-2,0];
            // var height=4;
            var arrLength = arrX.length;
            var geometry = new THREE.Geometry();
            for (var i = 0; i < arrLength; i++) {
                geometry.vertices.push(new THREE.Vector3(arrX[i], height, arrZ[i]));
            }
            for (var i = 0; i < arrLength; i++) {
                geometry.vertices.push(new THREE.Vector3(arrX[i], 0, arrZ[i]));
            }
            for (var i = 0; i < arrLength; i++) {
                if (i + arrLength + 1 == 2 * arrLength) {
                    geometry.faces.push(new THREE.Face3(i, (i + 1) % arrLength, arrLength));
                    geometry.faces.push(new THREE.Face3(i, arrLength, i + arrLength));
                } else {
                    geometry.faces.push(new THREE.Face3(i, (i + 1) % arrLength, i + arrLength + 1));
                    geometry.faces.push(new THREE.Face3(i, i + arrLength + 1, i + arrLength));
                }
            }
            for (var i = 0; i < arrLength - 2; i++) {
                geometry.faces.push(new THREE.Face3(0, i + 2, i + 1));
            }
            for (var i = 0; i < arrLength - 2; i++) {
                geometry.faces.push(new THREE.Face3(arrLength, arrLength + i + 1, arrLength + i + 2));
            }
            geometry.computeFaceNormals();
            var material = new THREE.MeshLambertMaterial({ //创建材料
                color: 0x8DEEEE,
                wireframe: false
            });
            var mesh = new THREE.Mesh(geometry, material);

            scene.add(mesh);
            //objects.push(mesh);
        }

        function addMulGeometryText() {
            var arrX = [67.18841944111367, 65.17594444951699, 56.737672119402966, 58.75014711099965];
            var arrZ = [157.04366246983577, 152.91279275128568, 155.91385194907826, 160.0447216678792];
            var height = 24;
            var arrLength = arrX.length;
            var geometry = new THREE.Geometry();
            for (var i = 0; i < arrLength; i++) {
                geometry.vertices.push(new THREE.Vector3(arrX[i], height, arrZ[i]));
            }
            for (var i = 0; i < arrLength; i++) {
                geometry.vertices.push(new THREE.Vector3(arrX[i], 0, arrZ[i]));
            }
            for (var i = 0; i < arrLength; i++) {
                if (i + arrLength + 1 == 2 * arrLength) {
                    geometry.faces.push(new THREE.Face3(i, (i + 1) % arrLength, arrLength));
                    geometry.faces.push(new THREE.Face3(i, arrLength, i + arrLength));
                } else {
                    geometry.faces.push(new THREE.Face3(i, (i + 1) % arrLength, i + arrLength + 1));
                    geometry.faces.push(new THREE.Face3(i, i + arrLength + 1, i + arrLength));
                }
            }
            for (var i = 0; i < arrLength - 2; i++) {
                geometry.faces.push(new THREE.Face3(0, i + 2, i + 1));
            }
            for (var i = 0; i < arrLength - 2; i++) {
                geometry.faces.push(new THREE.Face3(arrLength, arrLength + i + 1, arrLength + i + 2));
            }
            geometry.computeFaceNormals();
            var material = new THREE.MeshLambertMaterial({ //创建材料
                color: 0xffff00,
                wireframe: false
            });
            var mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
        }

        function addOwnGeometry() {
            var arrX = [0, 0, 4, 4];
            var arrY = [0, 4, 4, 0];
            var height = 4;
            var arrLength = arrX.length;
            // 创建一个立方体
            //    v6----- v5
            //   /|      /|
            //  v1------v0|
            //  | |     | |
            //  | |v7---|-|v4
            //  |/      |/
            //  v2------v3
            var geometry = new THREE.Geometry();
            //创建立方体的顶点
            //[x,y,z]
            //
            //        |y
            //        |
            //     (0,0,0)------x
            //       /
            //      /z
            var vertices = [
                new THREE.Vector3(10, 10, 10), //v0
                new THREE.Vector3(-10, 10, 10), //v1
                new THREE.Vector3(-10, -10, 10), //v2
                new THREE.Vector3(10, -10, 10), //v3
                new THREE.Vector3(10, -10, -10), //v4
                new THREE.Vector3(10, 10, -10), //v5
                new THREE.Vector3(-10, 10, -10), //v6
                new THREE.Vector3(-10, -10, -10) //v7
            ];

            geometry.vertices = vertices;
            //创建立方的面
            var faces = [
                new THREE.Face3(0, 1, 2),
                new THREE.Face3(0, 2, 3),
                new THREE.Face3(0, 3, 4),
                new THREE.Face3(0, 4, 5),
                new THREE.Face3(1, 6, 7),
                new THREE.Face3(1, 7, 2),
                new THREE.Face3(6, 5, 4),
                new THREE.Face3(6, 4, 7),
                new THREE.Face3(5, 6, 1),
                new THREE.Face3(5, 1, 0),
                new THREE.Face3(3, 2, 7),
                new THREE.Face3(3, 7, 4)
            ];

            geometry.faces = faces;
            //geometry.faces.push(new THREE.Face4(0, 1, 2, 3));
            // for(var i=0;i<arrLength;i++){
            //     geometry.vertices.push(new THREE.Vector3(arrX[i], arrY[i], height));
            // }
            // for(var i=0;i<arrLength;i++){
            //     geometry.vertices.push(new THREE.Vector3(arrX[i], arrY[i], 0));
            // }

            // for(var i=1;i<=arrLength-1;i++){
            //     geometry.faces.push(new THREE.Face3(0, i, (i+1)%arrLength));
            // }

            // for(var i=0;i<arrLength-1;i++){
            //     var temp=[i,(i+1)%arrLength,i+arrLength,(i+arrLength+1)]
            //     // temp[3]=temp[1]+arrLength
            //     geometry.faces.push(new THREE.Face3(temp[0], temp[1], temp[2]));
            //     geometry.faces.push(new THREE.Face3(temp[0], temp[1], temp[3]));
            //     geometry.faces.push(new THREE.Face3(temp[1], temp[2], temp[3]));

            // }
            // var temp=[0,arrLength-1,arrLength,arrLength*2-1]
            // geometry.faces.push(new THREE.Face3(temp[0], temp[1], temp[2]));
            // geometry.faces.push(new THREE.Face3(temp[0], temp[1], temp[3]));
            // geometry.faces.push(new THREE.Face3(temp[1], temp[2], temp[3]));

            // for(var i=1;i<=arrLength-2;i++){
            //     geometry.faces.push(new THREE.Face3(0+arrLength, i+arrLength, i+1+arrLength));
            // }
            // for(var i=0;i<=arrLength-2;i++){
            //     geometry.faces.push(new THREE.Face3(i, i+1, (i+2)%arrLength));
            // }
            // for(var i=0;i<=arrLength-2;i++){
            //     geometry.faces.push(new THREE.Face3(i+arrLength, i+1+arrLength, (i+2)%arrLength+arrLength));
            // }
            geometry.computeFaceNormals();
            var material = new THREE.MeshLambertMaterial({ //创建材料
                color: 0xffff00,
                wireframe: false
            });
            var mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
        }

        function addGeometry() {
            var geometry = new THREE.Geometry();
            // 设置顶点位置
            // 顶部4顶点
            geometry.vertices.push(new THREE.Vector3(-1, 2, -1));
            geometry.vertices.push(new THREE.Vector3(1, 2, -1));
            geometry.vertices.push(new THREE.Vector3(1, 2, 1));
            geometry.vertices.push(new THREE.Vector3(-1, 2, 1));
            // 底部4顶点
            geometry.vertices.push(new THREE.Vector3(-2, 0, -2));
            geometry.vertices.push(new THREE.Vector3(2, 0, -2));
            geometry.vertices.push(new THREE.Vector3(2, 0, 2));
            geometry.vertices.push(new THREE.Vector3(-2, 0, 2));

            // 设置顶点连接情况
            // 顶面
            geometry.faces.push(new THREE.Face3(0, 1, 3));
            geometry.faces.push(new THREE.Face3(1, 2, 3));
            //          geometry.faces.push(new THREE.Face4(0, 1, 2, 3));
            // 底面
            geometry.faces.push(new THREE.Face3(4, 5, 6));
            geometry.faces.push(new THREE.Face3(5, 6, 7));
            //          geometry.faces.push(new THREE.Face4(4, 5, 6, 7));
            // 侧面
            geometry.faces.push(new THREE.Face3(1, 5, 6));
            geometry.faces.push(new THREE.Face3(6, 2, 1));
            geometry.faces.push(new THREE.Face3(2, 6, 7));
            geometry.faces.push(new THREE.Face3(7, 3, 2));
            geometry.faces.push(new THREE.Face3(3, 7, 0));
            geometry.faces.push(new THREE.Face3(7, 4, 0));
            geometry.faces.push(new THREE.Face3(0, 4, 5));
            geometry.faces.push(new THREE.Face3(0, 5, 1));
            var material = new THREE.MeshLambertMaterial({ //创建材料
                color: 0xffff00,
                wireframe: false
            });
            var mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
        }


        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(objects);
            var intersect;
            if (intersects.length > 0) {
                intersect = intersects[0];
                rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
                //rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
            }
            var canvas = document.getElementById("locationCanvas");
            var cxt = canvas.getContext("2d");
            cxt.font = "15px Arial";
            cxt.clearRect(0, 0, 200, 40);
            var x = intersect.point.z;
            var y =  intersect.point.x;

            var longitude = x/80*(xmax - xmin) + (xmax + xmin) / 2;
            var latitude  = y/80*(xmax - xmin) + (ymax + ymin)  / 2;

            cxt.fillText(longitude, 10, 18);
            cxt.fillText(latitude, 10, 33);
            //render();
        }
        function onDocumentMouseDown(event) {
            event.preventDefault();
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(objects);
            if (intersects.length > 0) {
                var intersect = intersects[0];
                load3DS(intersect, "tx");
                scene.remove(rollOverMesh);
                var x = intersect.point.z;
                var y =  intersect.point.x;
                var longitude = x/80*(xmax - xmin) + (xmax + xmin) / 2;
                var latitude  = y/80*(xmax - xmin) + (ymax + ymin)  / 2;
                TxDTO = { "type" : "tx","longitude" : longitude , "latitude" : latitude};
                var str = JSON.stringify(TxDTO);
                sendMessage(str);
            }

            orbitControls.enabled = true;
            document.removeEventListener('mousemove', onDocumentMouseMove, false);
            document.removeEventListener('mousedown', onDocumentMouseDown, false);

        }

        function onDocumentMouseDown2(event) {
            event.preventDefault();
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(objects);
            if (intersects.length > 0) {
                var intersect = intersects[0];
                load3DS(intersect, "rx");
                scene.remove(rollOverMesh);
                var x = intersect.point.z;
                var y =  intersect.point.x;
                var longitude = x/80*(xmax - xmin) + (xmax + xmin) / 2;
                var latitude  = y/80*(xmax - xmin) + (ymax + ymin)  / 2;
                RxDTO = { "type": "rx", "longitude" : longitude , "latitude" : latitude};
                var str = JSON.stringify(RxDTO);
                sendMessage(str);
            }

            orbitControls.enabled = true;
            document.removeEventListener('mousemove', onDocumentMouseMove, false);
            document.removeEventListener('mousedown', onDocumentMouseDown2, false);

        }


        function onDocumentKeyDown(event) {
            switch (event.keyCode) {
                case 16: isShiftDown = true; break;
            }
        }
        function onDocumentKeyUp(event) {
            switch (event.keyCode) {
                case 16: isShiftDown = false; break;
            }
        }


        //渲染
        function render() {

            delta = clock.getDelta();
            orbitControls.update(delta);
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }

    </script>

</body>

</html>